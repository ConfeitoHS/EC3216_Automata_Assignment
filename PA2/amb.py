#
#  Automata Programming Assignment #2
#
#  Name: ConfeitoHS
#  ID: 20215---
#

import sys
import copy
# Do not import any other libraries


def is_variable(value):
    """
    Upper case letters are variables.
    :param value: Node value.
    :return: True or False.
    """
    return value.isupper()


def is_terminal(value):
    """
    Lower case letters are terminal symbols.
    :param value: Node Value.
    :return: True or False.
    """
    return value.islower()


class DerivationTree:
    def __init__(self, value, children=[]):
        """
        :param root_value: Root value of derivation tree. An English letter, upper case or lower case.
        :param children: A list of child nodes of root.
        """
        self.value = value
        self.children = children

    def print_tree(self, height=[]):
        """
        Do not modify this function!
        Just use it when you want to print out the tree.
        """
        height_level = len(height)
        tab_str = "|  "
        branch = "".join(map(lambda x: tab_str if x else "   ", height[:-1]))
        branch += "+--" if height_level > 0 else ""

        print(branch, self.value, sep='')
        for i, child in enumerate(self.children):
            isterminal = i == len(self.children) - 1
            child.print_tree([*height, not isterminal])

    def string(self):
        """
        :return: String made of terminal nodes of derivation tree.
        """
        # O(n)
        if len(self.children) == 0:
            return self.value

        result = ''
        for child in self.children:
            result += child.string()

        return result

    def length(self):
        """
        :return: Length of terminal nodes of derivation tree (not variables).
        """
        #O(n)
        cnt = 0
        tree_string = self.string()
        for ch in tree_string:
            if is_terminal(ch):
                cnt += 1
        return cnt


class CFG:
    def __init__(self, filename):
        # Production rules are stored in dictionary form.
        self.rules = {}
        with open(filename, "r") as fp1:
            lines = fp1.readlines()
            for line in lines:
                content = line.split()
                left = content[0]
                for right in content[1:]:
                    if right == '|' or right == '>':
                        continue
                    if self.rules.get(left) is None:
                        self.rules[left] = {right}

                    else:
                        self.rules[left].add(right)

    def make_child(self, tree):
        """
        :param tree: Derivation tree.
        :return l: list of derivation trees after only one leftmost variable production
        :return done: just check you have done production, necessary for recursion
                    if you don't use it, erase it.
        """
        # probably n + n log n ?
        if len(tree.children) == 0: # Leaf node
            if is_variable(tree.value):

                # No Reach to Variable
                if not tree.value in self.rules.keys():
                    return [], False

                # Wow Good Gazua
                alltrees = []
                for rule in self.rules[tree.value]:    # Make all possibilities
                    temptree = DerivationTree(tree.value)
                    temptree.children = [DerivationTree(val) for val in rule]
                    alltrees.append(temptree)
                return alltrees, True

            elif is_terminal(tree.value):
                return [], False

        else:   # Middle Node

            # For all child try to make derivation
            for idx,child in enumerate(tree.children):
                tinytrees, done = self.make_child(child)
                
                # if derivation is made in some child tree
                if done:
                    alltrees = []
                    # Duplicate trees and apply poissible derivations into childtree
                    for tiny in tinytrees:
                        temptree = copy.deepcopy(tree)
                        temptree.children[idx] = tiny
                        alltrees.append(temptree)
                    return alltrees, True
            
            # No child made derivation, Failure
            return [], False

    def make_string(self, l = 0):
        """
        :param l: length of string.
        :return: List of tree with string length l that can be generated by CFG
        """
        comp = []   # completed
        cur = [DerivationTree('S')] # derivating now

        # Minimum derivation always 2L-1 times
        # Because there is no lambda/unit productions
        # So at least produce one more var at one derivation, and change one var into terminal
        
        for i in range(2*l-1):
            nxt = []    # needs more derivation (len < l)

            for tr in cur:
                
                trees, done = self.make_child(tr)   # leftmost derivation

                if not done: # exception: if cannot derivatable
                    continue

                for tr2 in trees:
                    tr2str = tr2.string()
                    tr2len = 0
                    for ch in tr2str:
                        if is_terminal(ch):
                            tr2len+=1
                    
                    if len(tr2str) == tr2len and tr2len==l: # Complete!
                        comp.append(tr2)
                        # print(tr2str)
                    elif len(tr2str) != tr2len and len(tr2str) <= l:  # Needs more derivation
                        nxt.append(tr2)        
     
            if len(nxt):    # If more derivatable
                cur = nxt
            else:
                break
        return comp

    def ambiguous_checker(self,output=False,max_len=10,stop_imm=True):
        """
        Just check the ambiguity only for strings of length 10 or less.
        :return: True if ambiguous. False if not ambiguous.
        """

        comp = []   # completed strings
        cur = [DerivationTree('S')] # derivating now
        flag = False

        for i in range(max_len*2-1): # 2 * 10 - 1 SINCE WE DONT HAVE ANY LAMBDA TRANSITION
            if flag and stop_imm:
                break
            nxt = []    # needs more derivation 

            for tr in cur:
                trees, done = self.make_child(tr)   # leftmost derivation

                if not done: # exception: if cannot derivatable
                    continue

                for tr2 in trees:
                    tr2str = tr2.string()
                    tr2len = 0
                    for ch in tr2str:
                        if is_terminal(ch):
                            tr2len+=1
                    
                    if len(tr2str) == tr2len and tr2len <= max_len: # Derivation Completed
                        if comp.count(tr2str):
                            flag = True
                            #ambiguous!!!     
                        else:
                            comp.append(tr2str)

                    elif len(tr2str) != tr2len and len(tr2str) <= max_len:  # Needs more derivation
                        nxt.append(tr2)        
                    
            if len(nxt):    # If more derivatable
                cur = nxt
            else:
                break
        print(len(comp), "strings tested")
        if output:
            with open('tested_ambiguity.txt','w') as amb:
                amb.writelines([c+'\n' for c in sorted(comp)])
        return flag


def test(*args):
    """
    If you want to debug your code, use the test function.
    This confirms only one case, so even if you pass the test function, you may not get a perfect score.
    """
    if len(args) < 2:
        raise ValueError("Not enough arguments")

    filename = args[1]

    # Test for string and length in DerivationTree
    a = DerivationTree('a')
    b = DerivationTree('b')
    AA = DerivationTree('A')
    B = DerivationTree('B')
    A = DerivationTree('A')
    S = DerivationTree('S')
    B.children = [b]
    A.children = [AA, a]
    S.children = [A, B]
    if S.string() != "Aab":
        raise ValueError("Incorrect string function")
    else:
        print("Success String")
    if S.length() != 2:
        raise ValueError("Incorrect length function")
    else:
        print("Success Lenghth")

    # Test for make_child in CFG
    Q = CFG(filename)
    B = DerivationTree('B')
    A = DerivationTree('A')
    S = DerivationTree('S')
    S.children = [A, B]
    tree_list, _ = Q.make_child(S)
    str_list = []
    for tree in tree_list:
        str_list.append(tree.string())
    str_list.sort()
    if str_list != ["AaB", "aB"] and str_list != ["Ab"]:
        raise ValueError("Incorrect make_child function")
    else:
        print("Success make_child")

    # Test for make_string in CFG
    make_list = Q.make_string(4)
    if len(make_list) != 2:
        raise ValueError("Incorrect make_string function")
    else:
        print("Success make_string")

    # Test for ambiguous_checker in CFG
    if not Q.ambiguous_checker():
        raise ValueError("Incorrect ambiguous_checker function")
    else:
        print("Success ambiguous_checker")

def mytest(*args):
    """
    If you want to debug your code, use the test function.
    This confirms only one case, so even if you pass the test function, you may not get a perfect score.
    """
    if len(args) < 2:
        raise ValueError("Not enough arguments")

    filename = args[1]

    

    # Lefomost Derivation
    Q = CFG(filename)
    S = DerivationTree('S')
    a = DerivationTree('a')
    S.children = [a]
    tree_list, _ = Q.make_child(S)
    print(f"Start : {S.string()}")
    str_list = [tree.string() for tree in tree_list]
    print('\n'.join(str_list))
    # Test for make_string in CFG
    l = int(input("Make string length\n"))
    make_list = Q.make_string(l)
    print([ll.string() for ll in make_list])
    print(len(make_list))

    # Test for ambiguous_checker in CFG
    print("Ambiguous" if Q.ambiguous_checker() else "Unambiguous")

if __name__ == '__main__':
    args = sys.argv
    #mytest(*args)
    
    if len(args) <4:
        raise ValueError("Usage: python amb.py <input grammar> <max string length> <max ambiguity test length> <stop immediately true/false>")

    Q = CFG(args[1])
    l = int(args[2])
    ambl = int(args[3])
    stop = False if len(args)==5 and args[4].lower() =='false' else True
    tot = 0
    with open('strings.txt','w') as strs:
        for i in range(1,l+1):
            make_list = Q.make_string(i)
            make_list = set([ll.string()+'\n' for ll in make_list])
            tot+= len(make_list)
            strs.write(f'Length {i}, Total {len(make_list)} strings\n')
            strs.writelines(make_list)
            strs.write('\n')
    print(tot, "strings generated")
    print("Ambiguous" if Q.ambiguous_checker(output=True,max_len=ambl,stop_imm=stop) else "Unambiguous", "Grammar")
    
    
